First, define the problem clearly

mat has k sorted arrays

Let total number of elements across all arrays be N

Assume arrays are roughly similar size unless stated otherwise

âœ… Version 1: Divide & Conquer (merge like merge-sort)
mergeArrays(0, k-1)
â†’ recursively merge halves

â± Time Complexity

This behaves like merge sort on k arrays.

Each element participates in log k merges

Each merge is linear in elements merged

ğŸ‘‰ Time: O(N log k)

ğŸ’¾ Space Complexity

Recursion stack: O(log k)

Temporary arrays created during merges: O(N)

ğŸ‘‰ Space: O(N) auxiliary

ğŸ‘ Pros

Asymptotically faster

Scales well when k is large

Standard optimal solution

ğŸ‘ Cons

More complex

Recursive

Harder to write bug-free in interviews

âš ï¸ Version 2: Sequential merging (one by one)
ans = merge(ans, mat[0])
ans = merge(ans, mat[1])
ans = merge(ans, mat[2])
...

â± Time Complexity

This is the killer.

Worst case:

merge size 1 + size 2
merge size 2 + size 3
merge size 3 + size 4
...


Total work:

â‰ˆ N + 2N + 3N + ... â‰ˆ kN


ğŸ‘‰ Time: O(Nk) (worst case)
If arrays are equal-sized â†’ O(NÂ²)

ğŸ’¾ Space Complexity

New ArrayList every merge

Temporary storage grows every time

ğŸ‘‰ Space: O(N), but with more reallocations

ğŸ‘ Pros

Very easy to understand

Iterative

Fewer moving parts

ğŸ‘ Cons

Becomes very slow as k grows

Repeated copying of large arrays

ğŸ”¥ Direct comparison
Aspect	Divide & Conquer	Sequential Merge
Time	O(N log k) âœ…	O(Nk) âŒ
Space	O(N)	O(N)
Scalability	Excellent	Poor
Code simplicity	Medium	Easy
Interview preference	â­â­â­â­	â­â­
ğŸ§  Intuition (easy mental model)

Sequential merge:
â€œKeep re-reading the entire book every time you add a new chapterâ€

Divide & conquer:
â€œMerge chapters in pairs, then merge the merged chaptersâ€